================================================================================
GAME CONFIGURATION FOR WORDWYRM GAMES
================================================================================

This document outlines the required implementation for any game type to properly
integrate with:
- Analytics dashboard and AI analysis features
- Mobile support (orientation, swipe controls, pause handling)
- Session saving (only tracks class members)

================================================================================
OVERVIEW
================================================================================

The analytics system tracks individual question responses during gameplay and
stores them in the database. This data powers:
- Question-by-question breakdown on student detail pages
- AI-powered individual student analysis
- AI-powered class-wide analysis

================================================================================
REQUIRED DATA STRUCTURE
================================================================================

Each game must track responses in this format:

questionResponses: Record<string, {
  questionText: string;      // The full question text
  selectedAnswer: string;    // What the student selected
  correctAnswer: string;     // The correct answer
  correct: boolean;          // Whether they got it right
}>

Example:
{
  "q0": {
    "questionText": "What is the capital of France?",
    "selectedAnswer": "Paris",
    "correctAnswer": "Paris",
    "correct": true
  },
  "q1": {
    "questionText": "What is 2 + 2?",
    "selectedAnswer": "5",
    "correctAnswer": "4",
    "correct": false
  }
}

Key naming convention: Use "q0", "q1", "q2", etc. for question keys.

================================================================================
IMPLEMENTATION STEPS
================================================================================

STEP 1: Add Tracking Variable
--------------------------------------------------------------------------------
At the top of your game class/component, initialize the tracking object:

// TypeScript
private questionResponses: Record<string, {
  questionText: string;
  selectedAnswer: string;
  correctAnswer: string;
  correct: boolean;
}> = {};

// JavaScript
this.questionResponses = {};


STEP 2: Track Correct Answers
--------------------------------------------------------------------------------
When a player answers correctly, record the response:

this.questionResponses[`q${currentQuestionIndex}`] = {
  questionText: currentQuestion.question,
  selectedAnswer: selectedAnswer,        // What they chose
  correctAnswer: currentQuestion.answer, // The correct answer
  correct: true
};


STEP 3: Track Wrong Answers
--------------------------------------------------------------------------------
When a player answers incorrectly, record the response:

this.questionResponses[`q${currentQuestionIndex}`] = {
  questionText: currentQuestion.question,
  selectedAnswer: selectedAnswer,        // What they chose (wrong)
  correctAnswer: currentQuestion.answer, // The correct answer
  correct: false
};


STEP 4: Pass Data to saveGameSession()
--------------------------------------------------------------------------------
When the game ends and you call saveGameSession(), include the questionResponses:

await saveGameSession(
  sessionId,
  score,
  correctAnswers,
  incorrectAnswers,
  completed,
  questionResponses  // <-- Add this parameter
);

The saveGameSession() function in app/actions/game.ts already accepts this
parameter and will store it in the database.


STEP 5: Reset on Game Restart (if applicable)
--------------------------------------------------------------------------------
If your game has a restart feature, reset the tracking object:

this.questionResponses = {};


================================================================================
EXAMPLE: SNAKE GAME IMPLEMENTATION
================================================================================

Reference file: lib/phaser/SnakeScene.ts

1. Variable declaration (lines 88-94):
   private questionResponses: Record<string, {
     questionText: string;
     selectedAnswer: string;
     correctAnswer: string;
     correct: boolean;
   }> = {};

2. Tracking correct answer (lines 1208-1215):
   const selectedAnswer = this.currentQuestion!.options[eatenApple.answerIndex];
   this.questionResponses[`q${this.currentQuestionIndex}`] = {
     questionText: this.currentQuestion!.question,
     selectedAnswer: selectedAnswer,
     correctAnswer: this.currentQuestion!.answer,
     correct: true
   };

3. Tracking wrong answer (lines 1281-1287):
   this.questionResponses[`q${this.currentQuestionIndex}`] = {
     questionText: this.currentQuestion!.question,
     selectedAnswer: studentAnswer,
     correctAnswer: this.currentQuestion!.answer,
     correct: false
   };

4. Saving session (lines 2048, 2063):
   await saveGameSession(
     this.sessionId,
     this.score,
     this.correctAnswers,
     this.incorrectAnswers,
     true,
     this.questionResponses
   );


================================================================================
IMPORTANT NOTES
================================================================================

1. Question Index Consistency
   - Use the same question index throughout (q0, q1, q2...)
   - Don't skip indices or use different naming

2. Track Every Question
   - Record both correct AND incorrect answers
   - Missing questions will show as gaps in the analytics

3. Store Original Question Text
   - Always store the full question text, not just an ID
   - This allows the AI to analyze the content of questions

4. Handle Edge Cases
   - If a player skips a question, still record it (with correct: false)
   - If a player answers the same question multiple times, only keep the
     final answer (overwrite the previous entry)

5. Don't Modify After Saving
   - Once saveGameSession() is called, the data is final
   - Any game restart should clear and start fresh


================================================================================
TESTING YOUR IMPLEMENTATION
================================================================================

1. Play through a game and answer some questions correctly and incorrectly

2. Check the database:
   - Look at the GameSession record
   - Verify questionResponses contains the expected data

3. Test the analytics pages:
   - Go to /teacher/analytics/[gameId]
   - Click on a student name
   - Verify the question breakdown shows correctly
   - Click "View AI Analysis" to test the AI analysis

4. Test class analysis:
   - Have multiple students play the game
   - Click "Analyze Class Performance"
   - Verify the class-wide insights are generated


================================================================================
TROUBLESHOOTING
================================================================================

Issue: Questions not showing in analytics
- Check that questionResponses is being passed to saveGameSession()
- Verify the data structure matches the expected format
- Check browser console for errors during save

Issue: Wrong answers showing as correct (or vice versa)
- Verify you're checking the answer correctly before setting correct: true/false
- Make sure selectedAnswer matches what the student actually chose

Issue: Missing questions in breakdown
- Ensure every question is recorded, even if skipped
- Check that question indices are sequential (q0, q1, q2...)

Issue: AI analysis fails
- Verify there are enough questions answered (at least 1)
- Check that questionText is not empty or undefined
- Look at server logs for Gemini API errors


================================================================================
MOBILE SUPPORT INTEGRATION
================================================================================

WordWyrm provides a reusable MobileSupport class for all Phaser games.

File: lib/phaser/MobileSupport.ts

FEATURES:
- Mobile device detection
- Landscape orientation enforcement with overlay
- Swipe controls for direction-based games
- Tab/app switch pause with 3-2-1 countdown
- Browser gesture prevention (pull-to-refresh, back-swipe)

--------------------------------------------------------------------------------
BASIC USAGE (No Swipe Controls)
--------------------------------------------------------------------------------

import { MobileSupport } from '@/lib/phaser/MobileSupport';

export default class YourScene extends Phaser.Scene {
  private mobileSupport!: MobileSupport;

  create() {
    // ... your game setup ...

    // Initialize mobile support
    this.mobileSupport = new MobileSupport(this);
    this.mobileSupport.setup();
  }

  update(time: number, delta: number) {
    // Check if paused due to mobile state (orientation/visibility)
    if (this.mobileSupport.isPaused()) {
      return;
    }

    // ... your game logic ...
  }

  shutdown() {
    // Clean up event listeners
    this.mobileSupport.destroy();
  }
}

--------------------------------------------------------------------------------
WITH SWIPE CONTROLS (For Direction-Based Games)
--------------------------------------------------------------------------------

import { MobileSupport, SwipeHandler } from '@/lib/phaser/MobileSupport';

export default class YourScene extends Phaser.Scene {
  private mobileSupport!: MobileSupport;
  private direction = 'RIGHT';
  private nextDirection = 'RIGHT';
  private gameStarted = false;

  create() {
    // ... your game setup ...

    // Initialize mobile support with swipe handler
    this.mobileSupport = new MobileSupport(this);

    const swipeHandler: SwipeHandler = {
      onSwipeUp: () => {
        if (this.direction !== 'DOWN') this.nextDirection = 'UP';
      },
      onSwipeDown: () => {
        if (this.direction !== 'UP') this.nextDirection = 'DOWN';
      },
      onSwipeLeft: () => {
        if (this.direction !== 'RIGHT') this.nextDirection = 'LEFT';
      },
      onSwipeRight: () => {
        if (this.direction !== 'LEFT') this.nextDirection = 'RIGHT';
      }
    };

    // Pass swipe handler and game started callback
    this.mobileSupport.setup(
      swipeHandler,
      () => this.gameStarted  // Used to determine if visibility pause should show countdown
    );
  }

  update(time: number, delta: number) {
    if (this.mobileSupport.isPaused()) {
      return;
    }

    // ... your game logic ...
  }

  shutdown() {
    this.mobileSupport.destroy();
  }
}

--------------------------------------------------------------------------------
IMPORTANT NOTES
--------------------------------------------------------------------------------

1. Orientation Overlay
   - Automatically shows when device is in portrait mode
   - Game is paused behind the overlay
   - Disappears when user rotates to landscape

2. Countdown Overlay
   - Shows 3-2-1 countdown when:
     - First entering landscape mode on mobile
     - Returning from tab/app switch
   - Gives user time to get ready before game resumes

3. Desktop Behavior
   - All mobile features are disabled on desktop
   - isMobile check uses 'ontouchstart' and maxTouchPoints

4. Swipe Controls
   - Minimum 30px swipe distance threshold
   - Uses dominant axis (horizontal vs vertical)
   - Prevents accidental direction changes


================================================================================
SESSION SAVING AND ANALYTICS
================================================================================

IMPORTANT: Analytics are ONLY tracked for class members!

When a game ends, call saveGameSession() to save the player's results.
The server will automatically:
- Check if the user is authenticated
- Check if they are a member of the game's class
- Only save analytics for class members
- Return success (with sessionId: 'not-tracked') for non-class members

This allows anyone to play via QR code/share link, but only class members
will have their results appear in the teacher's analytics dashboard.

--------------------------------------------------------------------------------
EXAMPLE SAVE SESSION IMPLEMENTATION
--------------------------------------------------------------------------------

async saveSession() {
  // Skip if no gameId (demo mode)
  if (!this.gameId) {
    return;
  }

  try {
    const { saveGameSession } = await import('@/app/actions/game');

    const result = await saveGameSession({
      gameId: this.gameId,
      score: this.score,
      correctAnswers: this.correctAnswers,
      totalQuestions: this.quizData.questions.length,
      timeSpent: Math.floor((Date.now() - this.startTime) / 1000),
      metadata: {
        // Your game-specific stats
        longestStreak: this.longestStreak,
        finalLength: this.snake.length
      },
      questionResponses: this.questionResponses
    });

    if (!result.success) {
      console.error('Failed to save game session:', result.error);
    } else if (result.data.sessionId === 'not-tracked') {
      console.log('Game completed (analytics not tracked - not a class member)');
    } else {
      console.log('Game session saved successfully!');
    }
  } catch (error) {
    console.error('Error saving game session:', error);
  }
}

--------------------------------------------------------------------------------
KEY POINTS
--------------------------------------------------------------------------------

1. No Guest Names
   - Don't prompt for names - non-class members are simply not tracked
   - This keeps analytics clean and relevant

2. Silent Success
   - saveGameSession returns success even if not tracked
   - Check sessionId === 'not-tracked' to know if analytics were saved

3. Class Membership Check
   - Server checks if user is in the game's class
   - Only authenticated students in the class get full analytics


================================================================================
FUTURE CONSIDERATIONS
================================================================================

Optional enhancements you could add:
- Time per question (add timeSpent field)
- Number of attempts per question
- Hints used
- Difficulty rating

These would require:
1. Adding fields to the questionResponses structure
2. Updating the tracking logic in each game
3. Updating the analytics pages to display the new data
4. Updating the AI prompts to consider the new data


================================================================================
END OF DOCUMENT
================================================================================